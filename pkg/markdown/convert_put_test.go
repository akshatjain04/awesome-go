package markdown

import (
	"bytes"
	"testing"

	"github.com/yuin/goldmark/util"
)

// IDGenerator struct
type IDGenerator struct {
	used map[string]bool
}

// Put function for IDGenerator
func (g *IDGenerator) Put(value []byte) {
	g.used[util.BytesToReadOnlyString(value)] = true
}

// TestPut tests the Put function of the IDGenerator struct.
func TestPut(t *testing.T) {
	// Define test cases
	testCases := []struct {
		name     string
		input    []byte
		expected map[string]bool
	}{
		{
			name:     "Normal operation of Put function",
			input:    []byte("test"),
			expected: map[string]bool{"test": true},
		},
		{
			name:     "Put function with existing key",
			input:    []byte("existing"),
			expected: map[string]bool{"existing": true},
		},
		{
			name:     "Put function with empty byte slice",
			input:    []byte(""),
			expected: map[string]bool{"": true},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Arrange: Create an instance of IDGenerator with an empty 'used' map.
			idGen := &IDGenerator{
				used: make(map[string]bool),
			}
			// If the test case is "Put function with existing key", add the key to the 'used' map.
			if tc.name == "Put function with existing key" {
				idGen.used["existing"] = false
			}

			// Act: Invoke the Put function with the generated byte slice as the parameter.
			idGen.Put(tc.input)

			// Assert: Use Go testing facilities to verify that the 'used' map now contains the string representation of the byte slice, and its value is set to true.
			for k, v := range tc.expected {
				if got, ok := idGen.used[k]; !ok || got != v {
					t.Errorf("Put(%v) = %v; want %v", tc.input, got, v)
				}
			}
		})
	}
}
